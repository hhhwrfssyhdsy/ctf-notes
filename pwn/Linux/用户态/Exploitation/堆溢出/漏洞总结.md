# 概念
指在程序执行过程中，向堆（Heap）区域写入超出其分配内存边界的数据，从而覆盖了相邻的内存空间。
UAF是指释放后引用（Use-After-Free）漏洞，它是一种常见的内存安全问题。当程序释放了一个堆上的内存块，但后续仍然继续使用该已释放的内存块，就会产生UAF漏洞。攻击者可以利用UAF漏洞来执行恶意代码，读取敏感数据，控制程序的执行流程等。
CTF 中堆题越来越常见，因为堆管理机制复杂、多变，能产生大量可利用漏洞：UAF、Double Free、Fastbin Attack、Unsortedbin Attack、Tcache Attack 等等。
## glibc的堆结构
### Chunk结构(glibc ptmalloc)
```
Chunk:
  prev_size  （前一个chunk的大小，仅 prev_inuse = 0 时有效）
  size       （本chunk大小 + 标志位）
  user data  （malloc 返回的区域）
  ...
```
**size 字段最低三位标志位：**
- `PREV_INUSE = 1/0` 表示前一个 chunk 是否被分配
- `IS_MMAPPED` 记录当前 `chunk` 是否是由 mmap 分配的。
- `NON_MAIN_ARENA` 记录当前 `chunk` 是否不属于主线程，1 表示不属于，0 表示属于。
## Chunk 分类

- fastbin（快速的小块）
- small bin（固定大小，双向链表）
- large bin（按大小排序的双链表）
- unsorted bin（free 之后首先进入的桶）
- tcache（GLIBC 2.26+ 新增，更简单更常用）
 **常见触发方式**
 - `strcpy` / `gets` 不检查长度
- `read(fd, buf, bigsize)`
- `memcpy` 错误 size
- 结构体数量不检查
## Arena堆管理器

**Arena 是 glibc 为了管理堆而设计的“堆管理器（heap manager）实例”。**
- 一个 **arena 管一个 heap 区域**
- 每个 arena 内有各种 bin（fastbin / smallbin / largebin / unsorted）
- 多线程时会有多个 arena，单线程通常只有一个 **main arena**
如果只有一个全局堆，那么多线程同时 malloc/free 会互相锁住，性能很差。
于是 glibc 设计：
- **main arena**：主线程使用的
- **thread arena**：线程私有的，每个线程一个（按需创建，每个最大 8MB）
不同线程在不同的 arena 上 malloc/free，不会互相锁住，提高并发性能。

**Arena包含两类重要的东西:**
**1.Bins —— 管理空闲 chunk**
包含：

- fastbins（多个大小）
- smallbins（双向链表）
- largebins（双向链表）
- unsorted bin（回收到此）
- tcache（线程局部缓存，但是单独存在，不属于 arena）
arena 负责决定 malloc/free 时 chunk 的来源或归属。
**2.top chunk（堆顶）**
每个 arena 有一个 top chunk，表示：
> 当前还能从系统中继续扩展堆的“末尾区域”。

malloc 找不到合适 chunk 时，就从 top 拿一块。
### 重点 1：Arena 位置 = Libc 位置泄露手段

例如：
free 大 chunk → 进入 unsorted bin：
`chunk->fd = main_arena + 88 chunk->bk = main_arena + 88`
如果能打印出 chunk->fd，就泄露了 main_arena 的地址，然后就可以算 libc base。
### 重点 2：所有 free chunk 都会挂到 arena 里的 bins
所以当：
- 堆溢出
- 篡改 chunk
- 攻击 fastbin / tcache / unsorted bin
其实是在攻击 **arena 中的链表结构**。


### 重点 3：每个 arena 的 top chunk 可以被伪造（House of Force）
CTF 基础进阶技巧：
**伪造 arena 的 top chunk → 可以让 malloc 返回任意地址。**
做法：
`top_chunk->size = -1（超大） malloc( huge_size ) → 返回你指定的位置`
这就是著名的 _House of Force_。
