---

title: ret2libc总结

date: 2025-11-07 22:03:38

tags:

---

```python

u64(p.recvuntil('\x7f')[-6:].ljust(8,b'\x00'))

```
在 x86_64 Linux 上，用户空间的高位地址通常形如 `0x00007fxxxxxxxx` —— 也就是说第 6 字节往高（最重要的非零字节）常常是 `0x7f`。
在内存中地址以 **小端**（little-endian）存储：低有效字节在低地址（前面），高有效字节在高地址（后面）。

* libc 动态地址通常在用户地址空间高位，其最高字节常为 `0x7f`（Linux x86\_64）。`recvuntil('\x7f')` 是常见的 heuristic（经验法）：因为 libc 地址的最高非零字节常常是 `0x7f`，所以读取到 `\x7f` 很可能刚好把地址的末尾也读进来。一直读取直到看到 `0x7f`（即地址结束字节）为止。

* `[-6:]`：因为 puts 打印地址通常会只输出低 6 个有效字节（高位为 0x00 0x00 0x7f），所以截 6 个字节就够了。然后 `ljust(8,b'\x00')` 填充到 8 个字节以便 `u64` 解析成 64-bit 小端整型。

* 结果就是 `puts_addr` 的真实值。

## 具体字节举例（更直观）

假设真实地址是 `0x00007ffff7a33450`。内存（小端）存储为：

`低地址 -> 高地址: 0x50 0x34 0xa3 0xf7 0xff 0x7f 0x00 0x00`

`recvuntil(b'\x7f')` 假设返回到包含 `0x7f`（返回的尾部包含那个 `0x7f`），例如：
`... 0x50 0x34 0xa3 0xf7 0xff 0x7f`
取 `[-6:]` 得到：
`b'\x50\x34\xa3\xf7\xff\x7f'`
再 `ljust(8,b'\x00')` →
`b'\x50\x34\xa3\xf7\xff\x7f\x00\x00'`
`u64(...)` → `0x00007ffff7a33450`，完美还原。


如果是32位程序则无需这么麻烦，直接固定读取4字节即可：
```python
leak = u32(p.recv(4))
```




**<font size="5">重要！！！进行libc泄露时注意栈对齐</font>**

### 栈对齐概念

在 **x86‑64 System V ABI** 中，有一个重要规定：

> **函数被调用时，`call` 指令执行后，栈顶 (%rsp) 必须对齐到 16 字节的倍数。**

>**在被调用函数的入口处（call 后）CPU 保证 `RSP % 16 == 0`。** 也就是说 **在执行 `call` 指令之前** 程序必须满足 `RSP % 16 == 8`，因为 `call` 会把返回地址压栈（占 8 字节），导致进入被调用函数时 `RSP` 刚好是 16 字节对齐的。


```
(call 前) RSP % 16 == 8 
(call 后) RSP % 16 == 0
```
`
### 为什么 ROP 会破坏对齐
**CALL 会把返回地址压栈（push 8 字节）**，而 **RET 从栈弹出返回地址（pop 8 字节）**。在正常函数调用路径里：

- 调用前：`RSP % 16 == 8`
- `call` 指令执行 → 返回地址被 push（`RSP -= 8`）
- 被调用函数入口：`RSP % 16 == 0`

但在 ROP 场景里，并不是通过 `call` 跳到函数（或到 PLT），而是通过覆盖返回地址并执行一连串 `ret`（或者直接 `ret` 到某个 PLT）把控制权交给目标地址。**没有 `call` 的那次 push 操作就“缺失”了**，所以目标函数看到的 `RSP` 会比它期望的少 8（或不在 16 的倍数位置）。
换句话说：
- 正常 `call` 流程：`RSP` 被 `call` 自动减 8（把返回地址 push）。
- ROP `ret` 流程：没有额外的 push，只有 pop/ret，导致进入 libc 函数时 `RSP` 比“规范”少 8（或说 `RSP % 16` 与期望值相差 8）。    

这个**差 8 字节** 就导致许多函数（尤其 glibc 里的函数或 PLT 入口）在执行使用 SSE 指令时崩溃。


## 为什么一个简单的 `ret` gadget（单纯的 `ret`）能修复问题？

单个 `ret` gadget 的行为就是：`RIP = [RSP]`；`RSP += 8`。也就是说执行一个 `ret` 会把 `RSP` 再往上移动 8 字节，相当于“补偿”缺失的那次 push/pop，从而把 `RSP` 的模 16 对齐状态恢复到被调用函数期望的状态。

举例：如果在进入 `puts` 前，`RSP % 16 == 8`（错位），插入一个 `ret` 会把 `RSP += 8`，于是变为 `RSP % 16 == 0`，对齐恢复，函数就不会因为对齐问题崩溃。

因此在 ROP 链中常会看到：

`payload = padding + p64(ret_gadget) + p64(pop_rdi) + p64(arg) + p64(puts_plt) + ...`

`ret_gadget` 的唯一作用是把栈上移 8 字节、修复对齐（尤其在调用 `system` 等时必须插入）。

## 为什么 ret2shellcode 通常不需要对齐？

- Shellcode 是自己写的机器码，直接执行 `execve`/`syscall` 系统调用。它**不依赖 glibc 的 ABI 前提**（也不执行 `movaps` 之类需要对齐的指令），所以即使 `RSP` 没有被调整为 16 的倍数，shellcode 也通常能正常执行。
    
- 只有当 shellcode 中使用了需要 16 字节对齐的 SSE 指令，或者会调用 libc 函数时才需要对齐。纯系统调用（`syscall`）本身不要求栈对齐为 16 的倍数。