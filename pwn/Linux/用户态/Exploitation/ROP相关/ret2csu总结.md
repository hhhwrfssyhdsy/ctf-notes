---

title: ret2csu总结

date: 2025-11-05 17:53:21

tags: pwn

categories: ctf学习

comment : true

---

### 64位函数参数传递方式

  

#### Linux X86 (常见)

  

当参数少于7个时， 参数从左到右放入寄存器(按顺序): rdi, rsi, rdx, rcx, r8, r9。例:

  

```cpp

H(a, b, c, d, e, f);

//a->%rdi, b->%rsi, c->%rdx, d->%rcx, e->%r8, f->%r9

//call H

```

  

当参数为7个以上时， 前 6 个与前面一样， 但后面的依次从右向左放入栈中(和32位一样）。因此，该漏洞基本上运用于64位程序。

  

```cpp

H(a, b, c, d, e, f, g, h);

//a->%rdi, b->%rsi, c->%rdx, d->%rcx, e->%r8, f->%r9

//h->8(%esp)

//g->(%esp)

//call H

```

  

Win64

  

与linux不同,win64中前4个参数总是放在寄存器中传递，剩余的参数则压入堆栈中这4个用于存放参数的寄存器分别是：存放整数参数的RCX，RDX，R8，R9；存放浮点数参数的XMM0，XMM1，XMM2，XMM3。

  

在大多数情况下，我们很难找到对应寄存器的gadgets，因此这个时候可以想到使用__libc_csu_init这个函数。

  

可以先来看该函数的汇编：

  

```x86asm

.text:00000000004005C0 ; void _libc_csu_init(void)

.text:00000000004005C0                 public __libc_csu_init

.text:00000000004005C0 __libc_csu_init proc near               ; DATA XREF: _start+16o

.text:00000000004005C0                 push    r15

.text:00000000004005C2                 push    r14

.text:00000000004005C4                 mov     r15d, edi

.text:00000000004005C7                 push    r13

.text:00000000004005C9                 push    r12

.text:00000000004005CB                 lea     r12, __frame_dummy_init_array_entry

.text:00000000004005D2                 push    rbp

.text:00000000004005D3                 lea     rbp, __do_global_dtors_aux_fini_array_entry

.text:00000000004005DA                 push    rbx

.text:00000000004005DB                 mov     r14, rsi

.text:00000000004005DE                 mov     r13, rdx

.text:00000000004005E1                 sub     rbp, r12

.text:00000000004005E4                 sub     rsp, 8

.text:00000000004005E8                 sar     rbp, 3

.text:00000000004005EC                 call    _init_proc

.text:00000000004005F1                 test    rbp, rbp

.text:00000000004005F4                 jz      short loc_400616

.text:00000000004005F6                 xor     ebx, ebx

.text:00000000004005F8                 nop     dword ptr [rax+rax+00000000h]

.text:0000000000400600

.text:0000000000400600 loc_400600:                             ; CODE XREF: __libc_csu_init+54j

.text:0000000000400600                 mov     rdx, r13

.text:0000000000400603                 mov     rsi, r14

.text:0000000000400606                 mov     edi, r15d

.text:0000000000400609                 call    qword ptr [r12+rbx*8]

.text:000000000040060D                 add     rbx, 1

.text:0000000000400611                 cmp     rbx, rbp

.text:0000000000400614                 jnz     short loc_400600

.text:0000000000400616

.text:0000000000400616 loc_400616:                             ; CODE XREF: __libc_csu_init+34j

.text:0000000000400616                 add     rsp, 8

.text:000000000040061A                 pop     rbx

.text:000000000040061B                 pop     rbp

.text:000000000040061C                 pop     r12

.text:000000000040061E                 pop     r13

.text:0000000000400620                 pop     r14

.text:0000000000400622                 pop     r15

.text:0000000000400624                 retn

.text:0000000000400624 __libc_csu_init endp

```

  

由汇编代码可知，我们可以通过控制0x400600和0x400616这两段地址下的汇编来控制寄存器 `rdx`、`rsi`、`rdi`(这里 `edi`为 `rdi`寄存器的低八位地址）。

  

### 例题： [level5](https://github.com/zhengmin1989/ROP_STEP_BY_STEP/blob/master/linux_x64/level5)

  

首先查看程序保护

  

```bash

 Arch:     amd64-64-little

    RELRO:    Partial RELRO

    Stack:    No canary found

    NX:       NX enabled

    PIE:      No PIE (0x400000)

```

  

程序为64位，有NX

  

既没有system函数也没有 `\bin\bash`字符串，要通过write函数泄露libc基址

  

write函数需要三个参数: `write (int fd, const void \* buf, size\_t count)`

  

```graphql

----------------------------------

| 寄存器和指令 |      存储数据      |

----------------------------------

|    rdi     |        1          | rdi存放第一参数，标准输出文件描述符：fd = 1

----------------------------------

|    rsi     |     write_got     | rsi存放第二参数，需要输出的内存地址：*buf = write_got

----------------------------------

|    rdx     |        8          | rdx存放第三参数，输出字节数：count = 8

----------------------------------

|    call    |     write_got     | call write_got调用write函数

----------------------------------

```

  
  
  

参考:

  

[ctfwiki-中级ROP](https://ctf-wiki.org/en/pwn/linux/user-mode/stackoverflow/x86/medium-rop/)

  

[Linux_x86下的ret2libc和ret2csu小记](https://lexsd6.github.io/2020/10/15/%E5%AD%A6%E4%B9%A0pwn%E5%B0%8F%E8%AE%B0(3)/)