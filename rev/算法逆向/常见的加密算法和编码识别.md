
通用解密方法：cyberchef

## Base64

### 概念
Base64 是一种基于 64 个可打印字符来表示二进制数据的表示方法。转换的时候，将 3 字节的数据，先后放入一个 24 位的缓冲区中，先来的字节占高位。数据不足 3 字节的话，于缓冲器中剩下的比特用 0 补足。每次取出 6 比特（因为 ![{\displaystyle 2^{6}=64}](https://wikimedia.org/api/rest_v1/media/math/render/svg/c4becc8d811901597b9807eccff60f0897e3701a)），按照其值选择`ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/`中的字符作为编码后的输出，直到全部输入数据转换完成。
### 识别
通常而言 Base64 的识别特征为索引表，当我们能找到 `ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/` 这样索引表，再经过简单的分析基本就能判定是 Base64 编码。
同时还可以找末端有`==`的

## TEA

### 概念

参考加密算法：
```C
#include <stdint.h> 
void encrypt (uint32_t* v, uint32_t* k) { 
uint32_t v0=v[0], v1=v[1], sum=0, i; /* set up */ 
uint32_t delta=0x9e3779b9; /* a key schedule constant */ 
uint32_t k0=k[0], k1=k[1], k2=k[2], k3=k[3]; /* cache key */ 
for (i=0; i < 32; i++) { 
/* basic cycle start */ 
sum += delta;
 v0 += ((v1<<4) + k0) ^ (v1 + sum) ^ ((v1>>5) + k1);
v1 += ((v0<<4) + k2) ^ (v0 + sum) ^ ((v0>>5) + k3); 
} 
/* end cycle */ 
v[0]=v0; 
v[1]=v1; 
} 
void decrypt (uint32_t* v, uint32_t* k) { 
uint32_t v0=v[0], v1=v[1], sum=0xC6EF3720, i; /* set up */ 
uint32_t delta=0x9e3779b9; /* a key schedule constant */
 uint32_t k0=k[0], k1=k[1], k2=k[2], k3=k[3]; /* cache key */ 
 for (i=0; i<32; i++) { 
 /* basic cycle start */ 
 v1 -= ((v0<<4) + k2) ^ (v0 + sum) ^ ((v0>>5) + k3); 
 v0 -= ((v1<<4) + k0) ^ (v1 + sum) ^ ((v1>>5) + k1); 
 sum -= delta; 
 } 
 /* end cycle */ 
 v[0]=v0; 
 v[1]=v1; 
 }
```

### 识别
最主要的识别特征就是 拥有一个 **magic number ：0x9e3779b9**

## RC4

### 概念
```C
void rc4_init(unsigned char *s, unsigned char *key, unsigned long Len) //初始化函数 { int i =0, j = 0; unsigned char k[256] = {0}; // 必须为无符号类型，否则会导致密文部分错误 unsigned char tmp = 0; for (i=0;i<256;i++) { s[i] = i; k[i] = key[i%Len]; } for (i=0; i<256; i++) { j=(j+s[i]+k[i])%256; tmp = s[i]; s[i] = s[j]; //交换s[i]和s[j] s[j] = tmp; } } void rc4_crypt(unsigned char *s, unsigned char *Data, unsigned long Len) //加解密 { int i = 0, j = 0, t = 0; unsigned long k = 0; unsigned char tmp; for(k=0;k<Len;k++) { i=(i+1)%256; j=(j+s[i])%256; tmp = s[i]; s[i] = s[j]; //交换s[x]和s[y] s[j] = tmp; t=(s[i]+s[j])%256; Data[k] ^= s[t]; } }
```
通过分析初始化代码，可以看出初始化代码中，对字符数组 s 进行了初始化赋值，且赋值分别递增。之后对 s 进行了 256 次交换操作。通过识别初始化代码，可以知道 rc4 算法。

其伪代码表示为：

初始化长度为 256 的 [S 盒](https://zh.wikipedia.org/wiki/S%E7%9B%92)。第一个 for 循环将 0 到 255 的互不重复的元素装入 S 盒。第二个 for 循环根据密钥打乱 S 盒。

  `for i from 0 to 255      S[i] := i  endfor  j := 0  for( i=0 ; i<256 ; i++)      j := (j + S[i] + key[i mod keylength]) % 256      swap values of S[i] and S[j]  endfor`

下面 i,j 是两个指针。每收到一个字节，就进行 while 循环。通过一定的算法（(a),(b)）定位 S 盒中的一个元素，并与输入字节异或，得到 k。循环中还改变了 S 盒（©）。如果输入的是[明文](https://zh.wikipedia.org/wiki/%E6%98%8E%E6%96%87)，输出的就是[密文](https://zh.wikipedia.org/wiki/%E5%AF%86%E6%96%87)；如果输入的是密文，输出的就是明文。

 `i := 0  j := 0  while GeneratingOutput:      i := (i + 1) mod 256   //a      j := (j + S[i]) mod 256 //b      swap values of S[i] and S[j]  //c      k := inputByte ^ S[(S[i] + S[j]) % 256]      output K  endwhile`

此算法保证每 256 次循环中 S 盒的每个元素至少被交换过一次

## MD5

### 识别

魔数：
```C
h0 = 0x67452301;
h1 = 0xefcdab89; 
h2 = 0x98badcfe;
h3 = 0x10325476;
```
